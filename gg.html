<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Impact Horizon</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        color: white;
      }
      #simulation-container {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="simulation-container"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';

      let scene, camera, renderer, earth, controls, textureLoader;
      const activeAnimations = [];
      const shootingStars = [];

      const impacts = [
        { year: 1799, lat: 48.2, lon: 0.1, size: 'small' },
        { year: 1803, lat: 48.7, lon: 0.6, size: 'shower' },
        { year: 1807, lat: 41.2, lon: -73.3, size: 'medium' },
        { year: 1825, lat: 13.7, lon: 77.5, size: 'small' },
        { year: 1827, lat: 26.3, lon: 75.8, size: 'small' },
        { year: 1836, lat: -5.1, lon: -36.6, size: 'medium' },
        { year: 1847, lat: 50.4, lon: 13.0, size: 'medium' },
        { year: 1860, lat: 39.9, lon: -81.7, size: 'small' },
        { year: 1863, lat: 58.5, lon: 25.8, size: 'small' },
        { year: 1866, lat: 48.9, lon: 22.5, size: 'large' },
        { year: 1868, lat: 52.7, lon: 21.0, size: 'shower' },
        { year: 1879, lat: 46.8, lon: 1.1, size: 'small' },
        { year: 1882, lat: 46.8, lon: 23.9, size: 'shower' },
        { year: 1888, lat: 35.5, lon: 45.4, size: 'medium' },
        { year: 1890, lat: 43.1, lon: -94.2, size: 'shower' },
        { year: 1908, lat: 60.9, lon: 101.9, size: 'massive' },
        { year: 1911, lat: 31.3, lon: 30.3, size: 'small' },
        { year: 1912, lat: 34.9, lon: -110.0, size: 'shower'},
        { year: 1924, lat: 40.4, lon: -104.7, size: 'medium'},
        { year: 1927, lat: 36.3, lon: 140.2, size: 'small' },
        { year: 1929, lat: 42.6, lon: 21.1, size: 'medium' },
        { year: 1938, lat: 14.1, lon: 120.9, size: 'shower' },
        { year: 1938, lat: 39.1, lon: -89.6, size: 'small' },
        { year: 1947, lat: 46.1, lon: 134.6, size: 'massive' },
        { year: 1949, lat: 53.0, lon: -4.0, size: 'small' },
        { year: 1952, lat: 54.0, lon: -112.8, size: 'medium'},
        { year: 1954, lat: 33.1, lon: -86.3, size: 'small' },
        { year: 1965, lat: 52.5, lon: -1.3, size: 'medium' },
        { year: 1969, lat: 26.9, lon: -105.3, size: 'massive'},
        { year: 1969, lat: -36.6, lon: 145.1, size: 'large' },
        { year: 1971, lat: 41.7, lon: -72.6, size: 'small' },
        { year: 1976, lat: 44.0, lon: 126.5, size: 'massive' },
        { year: 1977, lat: 38.2, lon: -85.7, size: 'medium' },
        { year: 1982, lat: 41.7, lon: -72.6, size: 'small' },
        { year: 1992, lat: 1.3, lon: 33.8, size: 'small' },
        { year: 1992, lat: 41.2, lon: -73.9, size: 'small' },
        { year: 1994, lat: 45.9, lon: -73.0, size: 'shower' },
        { year: 1998, lat: 34.0, lon: -103.5, size: 'large'},
        { year: 2003, lat: 41.5, lon: -87.6, size: 'shower' },
        { year: 2003, lat: 21.8, lon: 86.7, size: 'shower' },
        { year: 2007, lat: -16.6, lon: -69.1, size: 'large'},
        { year: 2008, lat: 21.0, lon: 31.0, size: 'shower' },
        { year: 2009, lat: 43.6, lon: -79.8, size: 'small' },
        { year: 2011, lat: 48.6, lon: 2.4, size: 'medium' },
        { year: 2013, lat: 54.9, lon: 61.3, size: 'massive' },
        { year: 2015, lat: 35.2, lon: 47.7, size: 'shower' },
        { year: 2018, lat: -22.4, lon: 22.4, size: 'medium' },
        { year: 2019, lat: 10.4, lon: -84.4, size: 'large' },
        { year: 2020, lat: 1.7, lon: 98.6, size: 'medium' },
        { year: 2021, lat: 51.1, lon: -116.9, size: 'medium'},
        { year: 2023, lat: 49.8, lon: 0.7, size: 'shower' },
        { year: 2023, lat: 40.6, lon: 16.6, size: 'small' },
        { year: 2024, lat: 52.6, lon: 12.8, size: 'shower' }
      ];

      init();
      animate();

      function init() {
        const container = document.getElementById("simulation-container");
        textureLoader = new THREE.TextureLoader();

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        camera = new THREE.PerspectiveCamera(
          45,
          container.clientWidth / container.clientHeight,
          0.1,
          2000
        );
        camera.position.set(0, 15, 40); 
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        createStarfield();
        createShootingStars();
        createCelestials();

        const earthGeometry = new THREE.SphereGeometry(1.5, 64, 64);
        const earthTexture = textureLoader.load(
          "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/land_ocean_ice_cloud_2048.jpg"
        );
        const earthMaterial = new THREE.MeshStandardMaterial({
          map: earthTexture,
        });
        earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2.5;
        controls.maxDistance = 50;
        controls.enabled = false;
        
        startIntroAnimation();

        window.addEventListener("resize", onWindowResize);
      }

      function startIntroAnimation() {
        const startPosition = new THREE.Vector3(0, 15, 40);
        const endPosition = new THREE.Vector3(0, 0, 5);
        const duration = 4000;

        const introAnimation = {
            startTime: Date.now(),
            update: () => {
                const elapsed = Date.now() - introAnimation.startTime;
                let t = Math.min(elapsed / duration, 1);
                t = t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;

                camera.position.lerpVectors(startPosition, endPosition, t);
                camera.lookAt(earth.position);

                if (t >= 1) {
                    introAnimation.isFinished = true;
                    controls.enabled = true;
                    scheduleImpacts();
                }
            }
        };
        activeAnimations.push(introAnimation);
      }
      
      function createStarfield() {
        const starVertices = [];
        for (let i = 0; i < 15000; i++) {
            const x = THREE.MathUtils.randFloatSpread(2000);
            const y = THREE.MathUtils.randFloatSpread(2000);
            const z = THREE.MathUtils.randFloatSpread(2000);
            starVertices.push(x, y, z);
        }
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.5,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
      }

      function createShootingStars() {
          const shootingStarGeometry = new THREE.SphereGeometry(0.05, 8, 8);
          const shootingStarMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, emissive: 0xffffff });
          for (let i = 0; i < 5; i++) {
              const star = new THREE.Mesh(shootingStarGeometry, shootingStarMaterial);
              resetShootingStar(star);
              scene.add(star);
              shootingStars.push(star);
          }
      }

      function resetShootingStar(star) {
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * 50 + 80;
          star.position.set(
              Math.cos(angle) * radius,
              THREE.MathUtils.randFloatSpread(50),
              Math.sin(angle) * radius
          );
          
          const target = new THREE.Vector3(
              THREE.MathUtils.randFloatSpread(20),
              THREE.MathUtils.randFloatSpread(20),
              0
          );
          star.userData.velocity = target.sub(star.position).normalize().multiplyScalar(THREE.MathUtils.randFloat(0.5, 1.0));
          star.userData.lifetime = THREE.MathUtils.randFloat(200, 400);
      }

      function createCelestials() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(20, 5, 5); 
        scene.add(directionalLight);
        
        const textureFlare0 = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare0.png');
        const textureFlare3 = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lensflare/lensflare3.png');
        
        const lensflare = new Lensflare();
        lensflare.addElement(new LensflareElement(textureFlare0, 700, 0, directionalLight.color));
        lensflare.addElement(new LensflareElement(textureFlare3, 60, 0.6));
        lensflare.addElement(new LensflareElement(textureFlare3, 70, 0.7));
        lensflare.addElement(new LensflareElement(textureFlare3, 120, 0.9));
        lensflare.addElement(new LensflareElement(textureFlare3, 70, 1));
        directionalLight.add(lensflare);

        const marsGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const marsTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/mars_1k_color.jpg');
        const marsMaterial = new THREE.MeshStandardMaterial({ map: marsTexture });
        const mars = new THREE.Mesh(marsGeometry, marsMaterial);
        mars.position.set(-10, 2, -15);
        scene.add(mars);

        const jupiterGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const jupiterTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/jupiter2_1k.jpg');
        const jupiterMaterial = new THREE.MeshStandardMaterial({ map: jupiterTexture });
        const jupiter = new THREE.Mesh(jupiterGeometry, jupiterMaterial);
        jupiter.position.set(15, -4, -25);
        scene.add(jupiter);
      }

      function scheduleImpacts() {
        const interval = 2000; 

        impacts.forEach((impact, i) => {
          setTimeout(() => {
            createMeteorImpact(impact.lat, impact.lon, impact.year, impact.size);
          }, i * interval);
        });
        
        const totalDuration = impacts.length * interval;
        setTimeout(scheduleImpacts, totalDuration + 2000);
      }

      function onWindowResize() {
        const container = document.getElementById("simulation-container");
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }

      function latLonToVector3(lat, lon, radius = 1.5) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        const x = -radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        return new THREE.Vector3(x, y, z);
      }

      function createMeteorImpact(lat, lon, year, size) {
        const impactPos = latLonToVector3(lat, lon, 1.5);
        createImpactEffect(impactPos, size);
      }

      function createImpactEffect(position, size) {
        if (size === 'shower') {
            for (let i = 0; i < 5; i++) {
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.15,
                    (Math.random() - 0.5) * 0.15,
                    (Math.random() - 0.5) * 0.15
                );
                const showerPos = position.clone().add(offset);
                createCartoonExplosion(showerPos, 'small');
                createCrater(showerPos, 'small');
            }
        } else {
            createCartoonExplosion(position, size);
            createCrater(position, size);
        }
      }
      
      function createCartoonExplosion(position, size) {
          let scaleFactor;
          switch(size) {
              case 'small': scaleFactor = 0.1; break;
              case 'medium': scaleFactor = 0.15; break;
              case 'large': scaleFactor = 0.25; break;
              case 'massive': scaleFactor = 0.4; break;
              default: scaleFactor = 0.12;
          }

          const explosionGroup = new THREE.Group();

          const outerSphereGeo = new THREE.SphereGeometry(1, 16, 16);
          const outerSphereMat = new THREE.MeshBasicMaterial({
              color: 0xffaa00,
              transparent: true,
              opacity: 0.8
          });
          const outerSphere = new THREE.Mesh(outerSphereGeo, outerSphereMat);
          
          const innerSphereGeo = new THREE.SphereGeometry(1, 16, 16);
          const innerSphereMat = new THREE.MeshBasicMaterial({
              color: 0xffff00,
              transparent: true,
              opacity: 0.9
          });
          const innerSphere = new THREE.Mesh(innerSphereGeo, innerSphereMat);

          explosionGroup.add(outerSphere);
          explosionGroup.add(innerSphere);
          
          explosionGroup.position.copy(position.clone().normalize().multiplyScalar(1.51));
          explosionGroup.lookAt(new THREE.Vector3(0,0,0));
          earth.add(explosionGroup);
          
          const explosionAnimation = {
              startTime: Date.now(),
              duration: 800,
              update: () => {
                  const elapsed = Date.now() - explosionAnimation.startTime;
                  const t = Math.min(elapsed / explosionAnimation.duration, 1);
                  const easeT = 1 - Math.pow(1 - t, 3);

                  const currentOuterScale = easeT * scaleFactor;
                  const currentInnerScale = easeT * scaleFactor * 0.6;
                  
                  outerSphere.scale.set(currentOuterScale, currentOuterScale, currentOuterScale);
                  innerSphere.scale.set(currentInnerScale, currentInnerScale, currentInnerScale);
                  
                  outerSphere.material.opacity = 0.8 * (1 - t);
                  innerSphere.material.opacity = 0.9 * (1 - t);

                  if (t >= 1) {
                      earth.remove(explosionGroup);
                      explosionAnimation.isFinished = true;
                  }
              }
          };
          activeAnimations.push(explosionAnimation);
      }

      function createCrater(position, size) {
        let craterSize;
        switch(size) {
            case 'small': craterSize = 0.03; break;
            case 'medium': craterSize = 0.05; break;
            case 'large': craterSize = 0.08; break;
            case 'massive': craterSize = 0.12; break;
            default: craterSize = 0.04;
        }
        
        const craterGeometry = new THREE.CircleGeometry(craterSize, 32);
        const craterMaterial = new THREE.MeshBasicMaterial({
            color: 0x333333, 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9
        });
        const crater = new THREE.Mesh(craterGeometry, craterMaterial);

        crater.position.copy(position.clone().normalize().multiplyScalar(1.501));
        crater.lookAt(new THREE.Vector3(0, 0, 0));
        earth.add(crater);

        const craterAnimation = {
            startTime: Date.now(),
            duration: 12000,
            update: () => {
                const elapsed = Date.now() - craterAnimation.startTime;
                const t = Math.min(elapsed / craterAnimation.duration, 1);

                if (t > 0.5) {
                    const fadeT = (t - 0.5) * 2;
                    crater.material.opacity = 0.9 * (1 - fadeT);
                }

                if (t >= 1) {
                    earth.remove(crater);
                    craterAnimation.isFinished = true;
                }
            }
        };
        activeAnimations.push(craterAnimation);
      }

      function animate() {
        requestAnimationFrame(animate);

        for (let i = activeAnimations.length - 1; i >= 0; i--) {
            const anim = activeAnimations[i];
            if (anim) {
              anim.update();
              if (anim.isFinished) {
                  activeAnimations.splice(i, 1);
              }
            }
        }
        
        shootingStars.forEach(star => {
            star.position.add(star.userData.velocity);
            star.userData.lifetime -= 1;
            if (star.userData.lifetime <= 0) {
                resetShootingStar(star);
            }
        });

        earth.rotation.y += 0.0002;
        controls.update();
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>

